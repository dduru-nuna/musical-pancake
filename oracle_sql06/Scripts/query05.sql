/*
 * TRIGGER 객체
 *    - PL/SQL 구문을 사용하여 생성할 수 있는 객체
 *    - 테이블 또는 뷰에 INSERT, UPDATE, DELETE 문에 의한 변경이 발생할 경우
 *      자동으로 실행할 내용을 정의하여 실행하게 하는 객체
 *    - 변경 전/후를 구분하여 자동으로 실행할 내용을 정의할 수 있다.
 */
CREATE TABLE TEST1(
	   ID NUMBER
	 , NAME VARCHAR2(10)
);

CREATE TABLE TEST2(
	   ID NUMBER
	 , NAME VARCHAR2(10)
);

CREATE OR REPLACE TRIGGER TRI_SAMPLE1
AFTER INSERT ON TEST1       --BEFORE/AFTER , INSERT/UPDATE/DELETE
BEGIN
	DBMS_OUTPUT.PUT_LINE('트리거 동작!!');
END;

SELECT * FROM USER_ERRORS;

INSERT INTO TEST1 VALUES(1, 'A');

CREATE OR REPLACE TRIGGER TRI_SAMPLE2
AFTER INSERT ON TEST1 FOR EACH ROW
BEGIN
	INSERT INTO TEST2 VALUES(:NEW.ID, :NEW.NAME);
END;
--TEST1 에 INSERT 작업을 하면 TEST2 에 데이터가 들어가는 트리거 생성.
--FOR EACH ROW(행 트리거) 를 쓸 때, :NEW.COLUMN_NAME, :OLD.COLUMN_NAME 형식 필요
--FOR EACH ROW 는 각 행마다 인서트가 동작(트리거)할 수 있도록 해준다
INSERT INTO TEST1 VALUES(3, 'C');
INSERT INTO TEST1(
	SELECT 4, 'D' FROM DUAL
	UNION ALL
	SELECT 5, 'E' FROM DUAL
	UNION ALL
	SELECT 6, 'F' FROM DUAL
);

SELECT * FROM TEST2;
SELECT * FROM TEST1;


CREATE OR REPLACE TRIGGER TRI_SAMPLE3
BEFORE UPDATE OF NAME ON TEST1 FOR EACH ROW  --NAME 컬럼이 UPDATE 되면 트리거 동작
BEGIN
	UPDATE TEST2
	   SET NAME = :NEW.NAME
	 WHERE ID = :NEW.ID;
	DBMS_OUTPUT.PUT_LINE('UPDATE 트리거 발생!!');
END;

UPDATE TEST1
   SET ID = ID * 10
 WHERE ID = 1;  --ID 수정하면 트리거 발생X
 
UPDATE TEST1
   SET NAME = 'b'
 WHERE ID = 2;  --NAME 수정하면 트리거 발생O
 
 

 
/* oracle_sql06-query04 문제 중
 * DEPARTMENTS 에 TOTAL 컬럼 추가하여 EMPLOYEES 사원 증가/감소할 때 부서에 따라 
 * TOTAL 인원 증가/감소하는 문제에 TRIGGER 적용해서 해봄*/ 
CREATE OR REPLACE TRIGGER TRI_ADD_EMPLOYEE
BEFORE INSERT ON EMPLOYEES FOR EACH ROW
BEGIN
	UPDATE DEPARTMENTS
	   SET TOTAL = TOTAL + 1
	 WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;
END;

SELECT * FROM DEPARTMENTS WHERE DEPARTMENT_ID = 60;
--TOTAL 7 인데 인서트 작업하고 나면 8 이 되어야 제대로 동작하는 것.

INSERT INTO EMPLOYEES VALUES(208, '홍', '길동', 'GILL', NULL, SYSDATE, 'IT_PROG', 4000, NULL, NULL, 60);
--TOTAL 8 로 변경됨.

CREATE OR REPLACE TRIGGER TRI_DEL_EMPLOYEE
BEFORE DELETE ON EMPLOYEES FOR EACH ROW
BEGIN
    UPDATE DEPARTMENTS
	   SET TOTAL = TOTAL - 1
	 WHERE DEPARTMENT_ID = :OLD.DEPARTMENT_ID;
	DBMS_OUTPUT.PUT_LINE(:OLD.FIRST_NAME || :OLD.LAST_NAME || :OLD.DEPARTMENT_ID);
    --DELETE 는 저장되어있던 이전 행을 없애는 것이니 :OLD 를 써야한다
END;

DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 208;


CREATE OR REPLACE TRIGGER TRI_MOD_EMPLOYEE
AFTER UPDATE OF DEPARTMENT_ID ON EMPLOYEES FOR EACH ROW
BEGIN
	UPDATE DEPARTMENTS
	   SET TOTAL = TOTAL + 1
	 WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;
	 
	UPDATE DEPARTMENTS
	   SET TOTAL = TOTAL - 1
	 WHERE DEPARTMENT_ID = :OLD.DEPARTMENT_ID;
	 
	DBMS_OUTPUT.PUT_LINE(:NEW.FIRST_NAME || :NEW.LAST_NAME || :NEW.DEPARTMENT_ID);
	DBMS_OUTPUT.PUT_LINE(:OLD.FIRST_NAME || :OLD.LAST_NAME || :OLD.DEPARTMENT_ID);
END;

--208번 사원 다시 넣고 하기
UPDATE EMPLOYEES SET DEPARTMENT_ID = 70 WHERE EMPLOYEE_ID = 208;
--출력이 NEW, OLD 구분되어서 나옴. 홍길동70 / 홍길동60
SELECT * FROM DEPARTMENTS WHERE DEPARTMENT_ID IN (60, 70);

SELECT * FROM USER_ERRORS;

--이렇게 트리거 만들어 놓으면 앞에 문제에서 INSERT 했을 때 트리거가 동작한다. TOTAL 인원 수가 
--추가로 증가/감소 하지 않도록 유의할 것 (앞에 INSERT 문을 제거하던지 새롭게 방법을 찾아야 한다)


--저장 안되서 날아가도 데이터베이스에 남아있는 것 확인 가능
SELECT * FROM USER_TRIGGER; --트리거 확인
SELECT * FROM USER_SOURCE; --프로시져는 여기서 확인 가능